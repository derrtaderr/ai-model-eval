"""
API endpoints for trace management.
"""

from datetime import datetime
from typing import Dict, Any, Optional, List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Query, status
from pydantic import BaseModel, Field
from sqlalchemy.ext.asyncio import AsyncSession

from ..auth.security import get_current_user_email
from ..database.connection import get_db
from ..services.trace_logger import trace_logger


router = APIRouter()


class TraceCreate(BaseModel):
    """Schema for creating a new trace."""
    user_input: str = Field(..., description="Input provided to the LLM")
    model_output: str = Field(..., description="Output generated by the LLM")
    model_name: str = Field(..., description="Name/identifier of the LLM model")
    system_prompt: Optional[str] = Field(None, description="System prompt used")
    session_id: Optional[str] = Field(None, description="Session identifier")
    metadata: Optional[Dict[str, Any]] = Field(None, description="Additional metadata")
    langsmith_run_id: Optional[str] = Field(None, description="LangSmith run ID")
    latency_ms: Optional[int] = Field(None, description="Response latency in milliseconds")
    token_count: Optional[Dict[str, int]] = Field(None, description="Token usage information")
    cost_usd: Optional[float] = Field(None, description="Estimated cost in USD")


class TraceResponse(BaseModel):
    """Schema for trace response."""
    id: str
    timestamp: str
    user_input: str
    model_output: str
    model_name: str
    system_prompt: Optional[str]
    user_id: Optional[str]
    session_id: Optional[str]
    metadata: Optional[Dict[str, Any]]
    latency_ms: Optional[int]
    token_count: Optional[Dict[str, int]]
    cost_usd: Optional[float]
    status: str
    langsmith_run_id: Optional[str]
    tags: List[Dict[str, Any]]


class TraceFilters(BaseModel):
    """Schema for trace filtering options."""
    model_name: Optional[str] = None
    session_id: Optional[str] = None
    tag_filters: Optional[Dict[str, List[str]]] = None
    start_date: Optional[datetime] = None
    end_date: Optional[datetime] = None


@router.post("/traces", response_model=Dict[str, str], status_code=status.HTTP_201_CREATED)
async def create_trace(
    trace_data: TraceCreate,
    current_user_email: str = Depends(get_current_user_email),
    db: AsyncSession = Depends(get_db)
):
    """
    Create a new trace record.
    
    This endpoint allows logging of LLM interactions for evaluation purposes.
    """
    try:
        # For now, we don't have user lookup implemented, so user_id will be None
        # In a full implementation, you'd look up the user by email
        trace_id = await trace_logger.log_trace(
            user_input=trace_data.user_input,
            model_output=trace_data.model_output,
            model_name=trace_data.model_name,
            system_prompt=trace_data.system_prompt,
            user_id=None,  # TODO: Implement user lookup
            session_id=trace_data.session_id,
            metadata=trace_data.metadata,
            langsmith_run_id=trace_data.langsmith_run_id,
            latency_ms=trace_data.latency_ms,
            token_count=trace_data.token_count,
            cost_usd=trace_data.cost_usd,
        )
        
        return {"trace_id": str(trace_id), "message": "Trace created successfully"}
    
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to create trace: {str(e)}"
        )


@router.get("/traces", response_model=List[TraceResponse])
async def get_traces(
    limit: int = Query(100, ge=1, le=1000, description="Number of traces to return"),
    offset: int = Query(0, ge=0, description="Number of traces to skip"),
    model_name: Optional[str] = Query(None, description="Filter by model name"),
    session_id: Optional[str] = Query(None, description="Filter by session ID"),
    current_user_email: str = Depends(get_current_user_email),
    db: AsyncSession = Depends(get_db)
):
    """
    Retrieve traces with optional filtering.
    
    Returns a paginated list of traces that can be filtered by various criteria.
    """
    try:
        traces = await trace_logger.get_traces(
            limit=limit,
            offset=offset,
            model_name=model_name,
            session_id=session_id,
            # TODO: Add user filtering when user management is implemented
        )
        
        return traces
    
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to retrieve traces: {str(e)}"
        )


@router.get("/traces/{trace_id}", response_model=TraceResponse)
async def get_trace(
    trace_id: str,
    current_user_email: str = Depends(get_current_user_email),
    db: AsyncSession = Depends(get_db)
):
    """
    Get a specific trace by its ID.
    
    Returns detailed information about a single trace.
    """
    try:
        trace_uuid = UUID(trace_id)
        trace = await trace_logger.get_trace_by_id(trace_uuid)
        
        if not trace:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Trace not found"
            )
        
        return trace
    
    except ValueError:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid trace ID format"
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to retrieve trace: {str(e)}"
        )


@router.post("/traces/search", response_model=List[TraceResponse])
async def search_traces(
    filters: TraceFilters,
    limit: int = Query(100, ge=1, le=1000, description="Number of traces to return"),
    offset: int = Query(0, ge=0, description="Number of traces to skip"),
    current_user_email: str = Depends(get_current_user_email),
    db: AsyncSession = Depends(get_db)
):
    """
    Search traces with advanced filtering options.
    
    Allows complex filtering by tags, date ranges, and other criteria.
    """
    try:
        traces = await trace_logger.get_traces(
            limit=limit,
            offset=offset,
            model_name=filters.model_name,
            session_id=filters.session_id,
            tag_filters=filters.tag_filters,
            start_date=filters.start_date,
            end_date=filters.end_date,
        )
        
        return traces
    
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to search traces: {str(e)}"
        )


@router.post("/traces/sync-langsmith", response_model=Dict[str, Any])
async def sync_langsmith_traces(
    project_name: Optional[str] = Query(None, description="LangSmith project to sync from"),
    current_user_email: str = Depends(get_current_user_email),
    db: AsyncSession = Depends(get_db)
):
    """
    Sync traces from LangSmith to the local database.
    
    This endpoint triggers a sync operation to import recent traces from LangSmith.
    """
    try:
        synced_count = await trace_logger.sync_from_langsmith(project_name)
        
        return {
            "message": f"Successfully synced {synced_count} traces from LangSmith",
            "synced_count": synced_count,
            "project_name": project_name or trace_logger.langsmith_project
        }
    
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to sync from LangSmith: {str(e)}"
        )


@router.get("/traces/stats/summary", response_model=Dict[str, Any])
async def get_trace_stats(
    current_user_email: str = Depends(get_current_user_email),
    db: AsyncSession = Depends(get_db)
):
    """
    Get summary statistics about traces.
    
    Returns counts, averages, and other metrics about the traces in the system.
    """
    try:
        # Get recent traces for statistics
        traces = await trace_logger.get_traces(limit=1000)
        
        if not traces:
            return {
                "total_traces": 0,
                "unique_models": 0,
                "unique_sessions": 0,
                "average_latency_ms": 0,
                "total_cost_usd": 0,
                "average_cost_usd": 0,
            }
        
        # Calculate statistics
        total_traces = len(traces)
        unique_models = len(set(trace["model_name"] for trace in traces))
        unique_sessions = len(set(trace["session_id"] for trace in traces if trace["session_id"]))
        
        latencies = [trace["latency_ms"] for trace in traces if trace["latency_ms"]]
        average_latency = sum(latencies) / len(latencies) if latencies else 0
        
        costs = [trace["cost_usd"] for trace in traces if trace["cost_usd"]]
        total_cost = sum(costs) if costs else 0
        average_cost = total_cost / len(costs) if costs else 0
        
        return {
            "total_traces": total_traces,
            "unique_models": unique_models,
            "unique_sessions": unique_sessions,
            "average_latency_ms": round(average_latency, 2),
            "total_cost_usd": round(total_cost, 4),
            "average_cost_usd": round(average_cost, 4),
        }
    
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get trace statistics: {str(e)}"
        ) 