"""
Trace logging service for capturing and managing LLM interactions.
"""

from datetime import datetime
from typing import Dict, Any, Optional, List
from uuid import UUID, uuid4
import asyncio
import logging

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_
from decouple import config
from sqlalchemy.sql import func

from database.models import Trace, User, TraceTag
from database.connection import AsyncSessionLocal

from langsmith import Client
from langchain.callbacks.tracers import LangChainTracer


class TraceLogger:
    """Service for logging and managing LLM traces."""
    
    def __init__(self):
        # LangSmith configuration
        self.langsmith_api_key = config("LANGCHAIN_API_KEY", default=None)
        self.langsmith_project = config("LANGCHAIN_PROJECT", default="llm-eval-platform")
        
        if self.langsmith_api_key:
            self.langsmith_client = Client(api_key=self.langsmith_api_key)
        else:
            self.langsmith_client = None
            print("Warning: LangSmith API key not found. LangSmith integration disabled.")
    
    async def log_trace(
        self,
        user_input: str,
        model_output: str,
        model_name: str,
        system_prompt: Optional[str] = None,
        user_id: Optional[UUID] = None,
        session_id: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None,
        langsmith_run_id: Optional[str] = None,
        latency_ms: Optional[int] = None,
        token_count: Optional[Dict[str, int]] = None,
        cost_usd: Optional[float] = None,
    ) -> UUID:
        """
        Log a trace to the database and optionally to LangSmith.
        
        Args:
            user_input: The input provided to the LLM
            model_output: The output generated by the LLM
            model_name: Name/identifier of the LLM model used
            system_prompt: System prompt used (if any)
            user_id: ID of the user who made the request
            session_id: Session identifier for grouping related traces
            metadata: Additional metadata about the trace
            langsmith_run_id: LangSmith run ID if available
            latency_ms: Response latency in milliseconds
            token_count: Token usage information
            cost_usd: Estimated cost in USD
            
        Returns:
            UUID of the created trace
        """
        async with AsyncSessionLocal() as session:
            # Create trace record
            trace = Trace(
                user_input=user_input,
                model_output=model_output,
                model_name=model_name,
                system_prompt=system_prompt,
                user_id=user_id,
                session_id=session_id,
                metadata=metadata or {},
                langsmith_run_id=langsmith_run_id,
                latency_ms=latency_ms,
                token_count=token_count,
                cost_usd=cost_usd,
                timestamp=datetime.utcnow(),
                status="completed"
            )
            
            session.add(trace)
            await session.commit()
            await session.refresh(trace)
            
            # Auto-generate tags if metadata contains relevant information
            await self._auto_tag_trace(session, trace)
            
            return trace.id
    
    async def _auto_tag_trace(self, session: AsyncSession, trace: Trace):
        """Automatically generate tags for a trace based on its content."""
        tags_to_add = []
        
        # Extract tags from metadata
        if trace.metadata:
            # Tool/function tags from metadata
            if "tools_used" in trace.metadata:
                for tool in trace.metadata["tools_used"]:
                    tags_to_add.append(("tool", tool))
            
            # Function call tags
            if "functions" in trace.metadata:
                for func in trace.metadata["functions"]:
                    if isinstance(func, dict) and "name" in func:
                        tags_to_add.append(("tool", func["name"]))
            
            # Scenario detection from metadata
            if "scenario" in trace.metadata:
                tags_to_add.append(("scenario", trace.metadata["scenario"]))
            
            # Custom tags from metadata
            if "tags" in trace.metadata:
                for tag in trace.metadata["tags"]:
                    if isinstance(tag, dict):
                        tag_type = tag.get("type", "custom")
                        tag_value = tag.get("value")
                        if tag_value:
                            tags_to_add.append((tag_type, tag_value))
                    elif isinstance(tag, str):
                        tags_to_add.append(("custom", tag))
        
        # Model provider tag
        model_lower = trace.model_name.lower()
        if "claude" in model_lower:
            tags_to_add.append(("provider", "anthropic"))
        elif "gpt" in model_lower or "openai" in model_lower:
            tags_to_add.append(("provider", "openai"))
        elif "gemini" in model_lower:
            tags_to_add.append(("provider", "google"))
        elif "llama" in model_lower:
            tags_to_add.append(("provider", "meta"))
        elif "mistral" in model_lower:
            tags_to_add.append(("provider", "mistral"))
        
        # Latency performance categories
        if trace.latency_ms:
            if trace.latency_ms < 1000:
                tags_to_add.append(("performance", "fast"))
            elif trace.latency_ms < 5000:
                tags_to_add.append(("performance", "medium"))
            else:
                tags_to_add.append(("performance", "slow"))
        
        # Cost categories
        if trace.cost_usd:
            if trace.cost_usd < 0.01:
                tags_to_add.append(("cost", "low"))
            elif trace.cost_usd < 0.05:
                tags_to_add.append(("cost", "medium"))
            else:
                tags_to_add.append(("cost", "high"))
        
        # Token count categories
        if trace.token_count:
            total_tokens = trace.token_count.get("input", 0) + trace.token_count.get("output", 0)
            if total_tokens < 500:
                tags_to_add.append(("length", "short"))
            elif total_tokens < 2000:
                tags_to_add.append(("length", "medium"))
            else:
                tags_to_add.append(("length", "long"))
        
        # Simple scenario detection based on input patterns
        user_input_lower = trace.user_input.lower()
        
        # Common patterns for real estate scenarios
        if any(word in user_input_lower for word in ["listing", "property", "house", "apartment", "real estate"]):
            tags_to_add.append(("scenario", "property_search"))
        elif any(word in user_input_lower for word in ["offer", "bid", "negotiate", "purchase"]):
            tags_to_add.append(("scenario", "offer_management"))
        elif any(word in user_input_lower for word in ["market", "price", "trend", "analysis"]):
            tags_to_add.append(("scenario", "market_analysis"))
        elif any(word in user_input_lower for word in ["email", "message", "contact", "communication"]):
            tags_to_add.append(("scenario", "communication"))
        elif any(word in user_input_lower for word in ["schedule", "appointment", "calendar", "meeting"]):
            tags_to_add.append(("scenario", "scheduling"))
        
        # Tool detection from user input and output
        combined_text = (trace.user_input + " " + trace.model_output).lower()
        
        if any(word in combined_text for word in ["search", "find", "lookup", "query"]):
            tags_to_add.append(("tool", "search"))
        elif any(word in combined_text for word in ["email", "send", "message"]):
            tags_to_add.append(("tool", "email"))
        elif any(word in combined_text for word in ["calendar", "schedule", "appointment"]):
            tags_to_add.append(("tool", "calendar"))
        elif any(word in combined_text for word in ["calculate", "computation", "math"]):
            tags_to_add.append(("tool", "calculator"))
        
        # Create tag records
        for tag_type, tag_value in tags_to_add:
            # Check if tag already exists for this trace
            existing_tag_query = select(TraceTag).where(
                and_(
                    TraceTag.trace_id == trace.id,
                    TraceTag.tag_type == tag_type,
                    TraceTag.tag_value == tag_value
                )
            )
            existing_result = await session.execute(existing_tag_query)
            existing_tag = existing_result.scalar_one_or_none()
            
            if not existing_tag:
                tag = TraceTag(
                    trace_id=trace.id,
                    tag_type=tag_type,
                    tag_value=tag_value,
                    confidence_score=1.0,  # High confidence for auto-generated tags
                    created_at=datetime.utcnow()
                )
                session.add(tag)
        
        await session.commit()
    
    async def add_manual_tags(
        self, 
        trace_id: UUID, 
        tags: List[Dict[str, Any]], 
        user_id: Optional[UUID] = None
    ) -> None:
        """
        Add manual tags to a trace.
        
        Args:
            trace_id: ID of the trace to tag
            tags: List of tag dictionaries with 'type', 'value', and optional 'confidence'
            user_id: ID of the user adding the tags
        """
        async with AsyncSessionLocal() as session:
            for tag_data in tags:
                tag_type = tag_data.get("type")
                tag_value = tag_data.get("value")
                confidence = tag_data.get("confidence", 0.9)  # Default confidence for manual tags
                
                if not tag_type or not tag_value:
                    continue
                
                # Check if tag already exists
                existing_tag_query = select(TraceTag).where(
                    and_(
                        TraceTag.trace_id == trace_id,
                        TraceTag.tag_type == tag_type,
                        TraceTag.tag_value == tag_value
                    )
                )
                existing_result = await session.execute(existing_tag_query)
                existing_tag = existing_result.scalar_one_or_none()
                
                if not existing_tag:
                    tag = TraceTag(
                        trace_id=trace_id,
                        tag_type=tag_type,
                        tag_value=tag_value,
                        confidence_score=confidence,
                        created_by=user_id,
                        created_at=datetime.utcnow()
                    )
                    session.add(tag)
            
            await session.commit()
    
    async def get_trace_tags(self, trace_id: UUID) -> List[Dict[str, Any]]:
        """Get all tags for a specific trace."""
        async with AsyncSessionLocal() as session:
            query = select(TraceTag).where(TraceTag.trace_id == trace_id)
            result = await session.execute(query)
            tags = result.scalars().all()
            
            return [
                {
                    "id": str(tag.id),
                    "type": tag.tag_type,
                    "value": tag.tag_value,
                    "confidence": tag.confidence_score,
                    "created_by": str(tag.created_by) if tag.created_by else None,
                    "created_at": tag.created_at.isoformat()
                }
                for tag in tags
            ]
    
    async def get_tag_taxonomy(self) -> Dict[str, List[Dict[str, Any]]]:
        """
        Get the current tag taxonomy for building dynamic filters.
        
        Returns:
            Dictionary with tag types as keys and lists of tag values with counts
        """
        async with AsyncSessionLocal() as session:
            # Get tag counts by type and value
            tag_stats_query = select(
                TraceTag.tag_type,
                TraceTag.tag_value,
                func.count(TraceTag.id).label('count'),
                func.avg(TraceTag.confidence_score).label('avg_confidence')
            ).group_by(TraceTag.tag_type, TraceTag.tag_value).order_by(
                TraceTag.tag_type, func.count(TraceTag.id).desc()
            )
            
            result = await session.execute(tag_stats_query)
            tag_data = result.all()
            
            taxonomy = {}
            for row in tag_data:
                if row.tag_type not in taxonomy:
                    taxonomy[row.tag_type] = []
                
                taxonomy[row.tag_type].append({
                    "value": row.tag_value,
                    "count": row.count,
                    "confidence": float(row.avg_confidence) if row.avg_confidence else None
                })
            
            return taxonomy
    
    async def get_traces(
        self,
        limit: int = 100,
        offset: int = 0,
        user_id: Optional[UUID] = None,
        model_name: Optional[str] = None,
        session_id: Optional[str] = None,
        tag_filters: Optional[Dict[str, List[str]]] = None,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
    ) -> List[Dict[str, Any]]:
        """
        Retrieve traces with filtering options.
        
        Args:
            limit: Maximum number of traces to return
            offset: Number of traces to skip
            user_id: Filter by user ID
            model_name: Filter by model name
            session_id: Filter by session ID
            tag_filters: Filter by tags (e.g., {"tool": ["search", "email"], "scenario": ["support"]})
            start_date: Filter traces after this date
            end_date: Filter traces before this date
            
        Returns:
            List of trace dictionaries
        """
        async with AsyncSessionLocal() as session:
            query = select(Trace).order_by(Trace.timestamp.desc())
            
            # Apply filters
            if user_id:
                query = query.where(Trace.user_id == user_id)
            if model_name:
                query = query.where(Trace.model_name == model_name)
            if session_id:
                query = query.where(Trace.session_id == session_id)
            if start_date:
                query = query.where(Trace.timestamp >= start_date)
            if end_date:
                query = query.where(Trace.timestamp <= end_date)
            
            # Tag filtering (join with TraceTag table)
            if tag_filters:
                for tag_type, tag_values in tag_filters.items():
                    query = query.join(TraceTag).where(
                        TraceTag.tag_type == tag_type,
                        TraceTag.tag_value.in_(tag_values)
                    )
            
            query = query.limit(limit).offset(offset)
            
            result = await session.execute(query)
            traces = result.scalars().all()
            
            # Convert to dictionaries and include tags
            trace_dicts = []
            for trace in traces:
                trace_dict = {
                    "id": str(trace.id),
                    "timestamp": trace.timestamp.isoformat(),
                    "user_input": trace.user_input,
                    "model_output": trace.model_output,
                    "model_name": trace.model_name,
                    "system_prompt": trace.system_prompt,
                    "user_id": str(trace.user_id) if trace.user_id else None,
                    "session_id": trace.session_id,
                    "metadata": trace.metadata,
                    "latency_ms": trace.latency_ms,
                    "token_count": trace.token_count,
                    "cost_usd": trace.cost_usd,
                    "status": trace.status,
                    "langsmith_run_id": trace.langsmith_run_id,
                }
                
                # Get tags for this trace
                tag_query = select(TraceTag).where(TraceTag.trace_id == trace.id)
                tag_result = await session.execute(tag_query)
                tags = tag_result.scalars().all()
                
                trace_dict["tags"] = [
                    {
                        "type": tag.tag_type,
                        "value": tag.tag_value,
                        "confidence": tag.confidence_score
                    }
                    for tag in tags
                ]
                
                trace_dicts.append(trace_dict)
            
            return trace_dicts
    
    async def get_trace_by_id(self, trace_id: UUID) -> Optional[Dict[str, Any]]:
        """Get a specific trace by its ID."""
        traces = await self.get_traces(limit=1, offset=0)
        async with AsyncSessionLocal() as session:
            query = select(Trace).where(Trace.id == trace_id)
            result = await session.execute(query)
            trace = result.scalar_one_or_none()
            
            if not trace:
                return None
            
            # Get tags
            tag_query = select(TraceTag).where(TraceTag.trace_id == trace.id)
            tag_result = await session.execute(tag_query)
            tags = tag_result.scalars().all()
            
            return {
                "id": str(trace.id),
                "timestamp": trace.timestamp.isoformat(),
                "user_input": trace.user_input,
                "model_output": trace.model_output,
                "model_name": trace.model_name,
                "system_prompt": trace.system_prompt,
                "user_id": str(trace.user_id) if trace.user_id else None,
                "session_id": trace.session_id,
                "metadata": trace.metadata,
                "latency_ms": trace.latency_ms,
                "token_count": trace.token_count,
                "cost_usd": trace.cost_usd,
                "status": trace.status,
                "langsmith_run_id": trace.langsmith_run_id,
                "tags": [
                    {
                        "type": tag.tag_type,
                        "value": tag.tag_value,
                        "confidence": tag.confidence_score
                    }
                    for tag in tags
                ]
            }
    
    async def sync_from_langsmith(self, project_name: Optional[str] = None) -> int:
        """
        Sync traces from LangSmith to the local database.
        
        Args:
            project_name: LangSmith project to sync from
            
        Returns:
            Number of traces synced
        """
        if not self.langsmith_client:
            raise ValueError("LangSmith client not configured")
        
        project_name = project_name or self.langsmith_project
        synced_count = 0
        
        try:
            # Get recent runs from LangSmith
            runs = list(self.langsmith_client.list_runs(
                project_name=project_name,
                limit=100  # Adjust as needed
            ))
            
            async with AsyncSessionLocal() as session:
                for run in runs:
                    # Check if we already have this trace
                    existing_query = select(Trace).where(Trace.langsmith_run_id == str(run.id))
                    existing_result = await session.execute(existing_query)
                    existing_trace = existing_result.scalar_one_or_none()
                    
                    if existing_trace:
                        continue  # Skip if already exists
                    
                    # Extract information from LangSmith run
                    inputs = run.inputs or {}
                    outputs = run.outputs or {}
                    
                    # Create trace record
                    trace = Trace(
                        user_input=str(inputs.get("input", "")),
                        model_output=str(outputs.get("output", "")),
                        model_name=run.extra.get("model_name", "unknown"),
                        system_prompt=inputs.get("system_prompt"),
                        session_id=run.session_id,
                        metadata={
                            "langsmith_metadata": run.extra,
                            "run_type": run.run_type,
                            "parent_run_id": str(run.parent_run_id) if run.parent_run_id else None,
                        },
                        langsmith_run_id=str(run.id),
                        latency_ms=int(run.total_time * 1000) if run.total_time else None,
                        cost_usd=run.total_cost,
                        timestamp=run.start_time or datetime.utcnow(),
                        status="completed" if run.status == "success" else "failed"
                    )
                    
                    session.add(trace)
                    synced_count += 1
                
                await session.commit()
        
        except Exception as e:
            print(f"Error syncing from LangSmith: {e}")
            raise
        
        return synced_count


# Global trace logger instance
trace_logger = TraceLogger() 