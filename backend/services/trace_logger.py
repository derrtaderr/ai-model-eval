"""
Trace logging service for capturing and managing LLM interactions.
"""

from datetime import datetime
from typing import Dict, Any, Optional, List
from uuid import UUID, uuid4
import asyncio
import logging

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from decouple import config

from database.models import Trace, User, TraceTag
from database.connection import AsyncSessionLocal

from langsmith import Client
from langchain.callbacks.tracers import LangChainTracer


class TraceLogger:
    """Service for logging and managing LLM traces."""
    
    def __init__(self):
        # LangSmith configuration
        self.langsmith_api_key = config("LANGCHAIN_API_KEY", default=None)
        self.langsmith_project = config("LANGCHAIN_PROJECT", default="llm-eval-platform")
        
        if self.langsmith_api_key:
            self.langsmith_client = Client(api_key=self.langsmith_api_key)
        else:
            self.langsmith_client = None
            print("Warning: LangSmith API key not found. LangSmith integration disabled.")
    
    async def log_trace(
        self,
        user_input: str,
        model_output: str,
        model_name: str,
        system_prompt: Optional[str] = None,
        user_id: Optional[UUID] = None,
        session_id: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None,
        langsmith_run_id: Optional[str] = None,
        latency_ms: Optional[int] = None,
        token_count: Optional[Dict[str, int]] = None,
        cost_usd: Optional[float] = None,
    ) -> UUID:
        """
        Log a trace to the database and optionally to LangSmith.
        
        Args:
            user_input: The input provided to the LLM
            model_output: The output generated by the LLM
            model_name: Name/identifier of the LLM model used
            system_prompt: System prompt used (if any)
            user_id: ID of the user who made the request
            session_id: Session identifier for grouping related traces
            metadata: Additional metadata about the trace
            langsmith_run_id: LangSmith run ID if available
            latency_ms: Response latency in milliseconds
            token_count: Token usage information
            cost_usd: Estimated cost in USD
            
        Returns:
            UUID of the created trace
        """
        async with AsyncSessionLocal() as session:
            # Create trace record
            trace = Trace(
                user_input=user_input,
                model_output=model_output,
                model_name=model_name,
                system_prompt=system_prompt,
                user_id=user_id,
                session_id=session_id,
                metadata=metadata or {},
                langsmith_run_id=langsmith_run_id,
                latency_ms=latency_ms,
                token_count=token_count,
                cost_usd=cost_usd,
                timestamp=datetime.utcnow(),
                status="completed"
            )
            
            session.add(trace)
            await session.commit()
            await session.refresh(trace)
            
            # Auto-generate tags if metadata contains relevant information
            await self._auto_tag_trace(session, trace)
            
            return trace.id
    
    async def _auto_tag_trace(self, session: AsyncSession, trace: Trace):
        """Automatically generate tags for a trace based on its content."""
        tags_to_add = []
        
        # Extract tags from metadata
        if trace.metadata:
            # Tool/function tags
            if "tools_used" in trace.metadata:
                for tool in trace.metadata["tools_used"]:
                    tags_to_add.append(("tool", tool))
            
            # Model provider tag
            if "claude" in trace.model_name.lower():
                tags_to_add.append(("provider", "anthropic"))
            elif "gpt" in trace.model_name.lower():
                tags_to_add.append(("provider", "openai"))
            elif "gemini" in trace.model_name.lower():
                tags_to_add.append(("provider", "google"))
            
            # Latency categories
            if trace.latency_ms:
                if trace.latency_ms < 1000:
                    tags_to_add.append(("latency", "fast"))
                elif trace.latency_ms < 5000:
                    tags_to_add.append(("latency", "medium"))
                else:
                    tags_to_add.append(("latency", "slow"))
        
        # Create tag records
        for tag_type, tag_value in tags_to_add:
            tag = TraceTag(
                trace_id=trace.id,
                tag_type=tag_type,
                tag_value=tag_value,
                confidence_score=1.0,  # High confidence for auto-generated tags
                created_at=datetime.utcnow()
            )
            session.add(tag)
        
        await session.commit()
    
    async def get_traces(
        self,
        limit: int = 100,
        offset: int = 0,
        user_id: Optional[UUID] = None,
        model_name: Optional[str] = None,
        session_id: Optional[str] = None,
        tag_filters: Optional[Dict[str, List[str]]] = None,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
    ) -> List[Dict[str, Any]]:
        """
        Retrieve traces with filtering options.
        
        Args:
            limit: Maximum number of traces to return
            offset: Number of traces to skip
            user_id: Filter by user ID
            model_name: Filter by model name
            session_id: Filter by session ID
            tag_filters: Filter by tags (e.g., {"tool": ["search", "email"], "scenario": ["support"]})
            start_date: Filter traces after this date
            end_date: Filter traces before this date
            
        Returns:
            List of trace dictionaries
        """
        async with AsyncSessionLocal() as session:
            query = select(Trace).order_by(Trace.timestamp.desc())
            
            # Apply filters
            if user_id:
                query = query.where(Trace.user_id == user_id)
            if model_name:
                query = query.where(Trace.model_name == model_name)
            if session_id:
                query = query.where(Trace.session_id == session_id)
            if start_date:
                query = query.where(Trace.timestamp >= start_date)
            if end_date:
                query = query.where(Trace.timestamp <= end_date)
            
            # Tag filtering (join with TraceTag table)
            if tag_filters:
                for tag_type, tag_values in tag_filters.items():
                    query = query.join(TraceTag).where(
                        TraceTag.tag_type == tag_type,
                        TraceTag.tag_value.in_(tag_values)
                    )
            
            query = query.limit(limit).offset(offset)
            
            result = await session.execute(query)
            traces = result.scalars().all()
            
            # Convert to dictionaries and include tags
            trace_dicts = []
            for trace in traces:
                trace_dict = {
                    "id": str(trace.id),
                    "timestamp": trace.timestamp.isoformat(),
                    "user_input": trace.user_input,
                    "model_output": trace.model_output,
                    "model_name": trace.model_name,
                    "system_prompt": trace.system_prompt,
                    "user_id": str(trace.user_id) if trace.user_id else None,
                    "session_id": trace.session_id,
                    "metadata": trace.metadata,
                    "latency_ms": trace.latency_ms,
                    "token_count": trace.token_count,
                    "cost_usd": trace.cost_usd,
                    "status": trace.status,
                    "langsmith_run_id": trace.langsmith_run_id,
                }
                
                # Get tags for this trace
                tag_query = select(TraceTag).where(TraceTag.trace_id == trace.id)
                tag_result = await session.execute(tag_query)
                tags = tag_result.scalars().all()
                
                trace_dict["tags"] = [
                    {
                        "type": tag.tag_type,
                        "value": tag.tag_value,
                        "confidence": tag.confidence_score
                    }
                    for tag in tags
                ]
                
                trace_dicts.append(trace_dict)
            
            return trace_dicts
    
    async def get_trace_by_id(self, trace_id: UUID) -> Optional[Dict[str, Any]]:
        """Get a specific trace by its ID."""
        traces = await self.get_traces(limit=1, offset=0)
        async with AsyncSessionLocal() as session:
            query = select(Trace).where(Trace.id == trace_id)
            result = await session.execute(query)
            trace = result.scalar_one_or_none()
            
            if not trace:
                return None
            
            # Get tags
            tag_query = select(TraceTag).where(TraceTag.trace_id == trace.id)
            tag_result = await session.execute(tag_query)
            tags = tag_result.scalars().all()
            
            return {
                "id": str(trace.id),
                "timestamp": trace.timestamp.isoformat(),
                "user_input": trace.user_input,
                "model_output": trace.model_output,
                "model_name": trace.model_name,
                "system_prompt": trace.system_prompt,
                "user_id": str(trace.user_id) if trace.user_id else None,
                "session_id": trace.session_id,
                "metadata": trace.metadata,
                "latency_ms": trace.latency_ms,
                "token_count": trace.token_count,
                "cost_usd": trace.cost_usd,
                "status": trace.status,
                "langsmith_run_id": trace.langsmith_run_id,
                "tags": [
                    {
                        "type": tag.tag_type,
                        "value": tag.tag_value,
                        "confidence": tag.confidence_score
                    }
                    for tag in tags
                ]
            }
    
    async def sync_from_langsmith(self, project_name: Optional[str] = None) -> int:
        """
        Sync traces from LangSmith to the local database.
        
        Args:
            project_name: LangSmith project to sync from
            
        Returns:
            Number of traces synced
        """
        if not self.langsmith_client:
            raise ValueError("LangSmith client not configured")
        
        project_name = project_name or self.langsmith_project
        synced_count = 0
        
        try:
            # Get recent runs from LangSmith
            runs = list(self.langsmith_client.list_runs(
                project_name=project_name,
                limit=100  # Adjust as needed
            ))
            
            async with AsyncSessionLocal() as session:
                for run in runs:
                    # Check if we already have this trace
                    existing_query = select(Trace).where(Trace.langsmith_run_id == str(run.id))
                    existing_result = await session.execute(existing_query)
                    existing_trace = existing_result.scalar_one_or_none()
                    
                    if existing_trace:
                        continue  # Skip if already exists
                    
                    # Extract information from LangSmith run
                    inputs = run.inputs or {}
                    outputs = run.outputs or {}
                    
                    # Create trace record
                    trace = Trace(
                        user_input=str(inputs.get("input", "")),
                        model_output=str(outputs.get("output", "")),
                        model_name=run.extra.get("model_name", "unknown"),
                        system_prompt=inputs.get("system_prompt"),
                        session_id=run.session_id,
                        metadata={
                            "langsmith_metadata": run.extra,
                            "run_type": run.run_type,
                            "parent_run_id": str(run.parent_run_id) if run.parent_run_id else None,
                        },
                        langsmith_run_id=str(run.id),
                        latency_ms=int(run.total_time * 1000) if run.total_time else None,
                        cost_usd=run.total_cost,
                        timestamp=run.start_time or datetime.utcnow(),
                        status="completed" if run.status == "success" else "failed"
                    )
                    
                    session.add(trace)
                    synced_count += 1
                
                await session.commit()
        
        except Exception as e:
            print(f"Error syncing from LangSmith: {e}")
            raise
        
        return synced_count


# Global trace logger instance
trace_logger = TraceLogger() 